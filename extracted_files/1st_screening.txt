プロジェクト名： Capability-Based Microkernel によるセキュアなユーザーレベルメモリ管理システム  申請者名：伊組烈火  【提案プロジェクト詳細】  1.   なにをつくるか  概要  Object-Capability Model による Capability-Based Microkernel をベースにした OS と ,   それを用いたユーザーラ  ンドメモリ管理システムを提案する .  この提案はセキュアかつ柔軟で安定したシステムの構築を可能とするものであり ,   ユーザーランドソフトウェアの  互換性を保ちつつ ,   最適化されたメモリ管理システムを提供可能である .  これにより，現代のプログラム技術におけるコンテナや Wasm, Hypervisor のような仮想化機構に対してより高レ  ベルの最適化を提供することが可能になる .  本提案で開発するものは以下の 3 つである :  ●   A9N : Capability-Based Microkernel  ●   KOITO : A9N をコアとする OS  ●   ULMM Server : KOITO 上で動作する ,   ユーザーレベルメモリ管理サーバー  ○   SLAB Allocator  ○   Buddy Memory Allocator  コンピューターの民主化による IoT の拡大  近年 ,   技術革新によるコンピュータの民主化は大きなムーブメントを引き起こしている .  ムーアの法則で予見されたように , CPU に含まれる面積当たりのトランジスタ数は指数関数的に増大した .   半導  体技術の進歩はよりコンパクトで低価格なコンピューターの発達を促し ,   21 世紀の携帯端末は   従来持っていた  電話機能のみならず ,   インターネットを介した広範なネットワークへの接続や高度なコンピューティング能力を獲  得し ,   より賢いものへと進化している .  これにより IoT という概念が一般化し ,   生活と密接かつ重大な結合を果たしている現在 ,   家の施錠システムまでも  がネットワークに参加するようになり ,   一つのモノに対して与えられるオペレーションが高度なものへと変貌を遂  げている .   そのニーズに応えるため ,   ありとあらゆるシステムに OS が搭載されるようになった .   この現象は ,   コン  ピュータの民主化による IoT の拡大と言えるだろう .  カーネルと OS  コンピュータの民主化が進む中で ,   カーネルと OS はますます重要な役割を果たすようになった .  カーネルは ,   システムとハードウェアを接続するための ,   プリミティブな API サブセットを提供するものである .   この  カーネルを基に ,   特定のユースケースを満たすためのソフトウェア群が一つのパッケージとなり , OS が構成され  る .  そのため ,   異なる OS でも同一のカーネルを使用しているケースが多数存在する .   代表的なもので言えば ,   数多  の Linux ディストリビューションや Android は Linux カーネルが用いられている .   また , Apple 社の iOS や macOS に  は XNU カーネルが用いられている .   カーネルが提供する API が共通であるため ,   各 OS を構成するソフトウェアは  高い互換性を持つ .  モノリシックなカーネル  従来のカーネルでは ,   一般的なシステム要求に対応するため ,   カーネル自体にその機能を含めてしまうというモ  ノリシックな構造を持っている .  例えば ,   デバイスドライバやファイルシステム ,   ネットワークに接続するためのプロトコル・スタックなどはカーネル  内部へ組み込まれる .   このアプローチは高速な動作を可能とするが ,   コンポーネントの拡大に伴いカーネルが肥  大化してしまうという問題を持っている .   また ,   構成要素である各コンポーネントのコードを書き換えるたびにカー  ネルの再ビルドが必要となる .   コードベースが十分に小さいうちは管理が可能であるが ,   開発の進行につれて保
守性と柔軟性を失ってしまい ,   誰もシステムの全容を把握できなくなる .   この状態ではカーネルの汎用性が低下  し ,   機能要件の小さな目的特化型の OS は ,   カーネルの提供する不要な機能に依存することとなる .   これにより ,  同じカーネルを組み込みシステムとデスクトップシステムの両方で使用するのは困難になる .  また ,   カーネル内に存在するコンポーネントは当然ながらカーネル空間上で動作する .   そのため , 1 つでも不安定  なコンポーネントが存在すると ,   その影響が最重要であるはずのカーネル全体に波及してしまう .  簡単に言えば ,   カーネルの担う仕事があまりにも多すぎるのである .  マイクロカーネル  モノリシックなカーネルの持つ問題を解消するため ,   マイクロカーネルというアイデアが提案された .  カーネルは最小の特権操作のみをユーザーに提供し ,   モノリシックカーネルにおける多くのカーネル内コンポー  ネントをユーザーランドへ移動することで ,   文字通り ” マイクロ ” にするというものである .   多くのマイクロカーネル  は割り込みやタイマー割り込み , IPC などの切り離せない操作のみを提供する .  切り離されたコンポーネントは IPC 機構によってクライアント - サーバーモデル [Tanenbaum, 2007] を実現し ,   協調  動作を行う .  この設計は先述したモノリシックカーネルの問題点を解消しているが ,   完璧ではない . IPC はユーザーからカーネ  ル ,   またその逆方向へのコンテキストスイッチを伴うため ,   単なる関数呼び出しで済んでいたものに対してオー  バーヘッドが課せられる .   しかしながら , L4 マイクロカーネルの作者である Jochen Liedtke が IPC を注意深く設計  することで高速な IPC を実現可能なことを示したことや [Liedtke, 1995],   技術革新によってコンピューターが高速  化したことに伴い ,   現代においては十二分に実用可能なものとなった .   そのため ,   ここでは問題としないことにす  る .  機構と方針の分離  マイクロカーネルが採用したアプローチは ,   機構と方針の分離 [Levin et al, 1975] という設計原則に一般化でき  る .   実装詳細である機構は ,   より抽象を表す方針を示してはならないという原則である .   マイクロカーネルにおい  ては ,   機構が IPC や割り込みを操作するための仕組みであり ,   方針はユーザーであるクライアントの操作詳細を  表す .  カーネルによるスケジューリング方針の決定  機構と方針の分離原則を適用すると ,   スケジューリングやメモリ管理システムの方針も分離できそうに思えるが ,  自体はそれほど単純ではない .  多くのマイクロカーネルにおいて ,   スケジューリングのための機構であるクロックドライバーはカーネル内部に存  在する .   何故なら ,   常にプリエンプティブマルチタスクを行うカーネルにとって ,   クロックサーバーからの IPC コスト  が無視できないものであるからだ .  通常のクライアント - サーバー間の IPC コストは全体から見たときにそれほど大きいものではない .   しかし ,   クロック  は 100-500hz という高頻度で発生するため ,   処理の大半を IPC が占める可能性が大きいためである .  そのため ,   妥協案として実行可能コンテキストごとの優先度設定機能が提供されている .  カーネルによるメモリ管理方針の決定  では ,   メモリ管理システムではどうだろうか .  ユーザーランドでメモリ管理方針を決定可能なマイクロカーネルは存在するが ,   多くの場合カーネル内に統合さ  れている .  では ,   何故多くのケースにおいてメモリ管理方針が移動できないのだろうか .   それは ,   セキュリティ上の問題に起  因する .  ユーザーが直接ページテーブルを操作できる場合 ,   自分の所有していない物理アドレスをマップすることや ,   他コ  ンテキストが持つアドレス空間を破壊することが可能となり ,   コンテキスト間の分離が損なわれてしまう .  MINIX のように , VM サーバーのような限定されたプロセスのみが操作可能とすることも現実的ではない .   このよ  うなユーザーに対する無条件の信頼は ,   悪意のあるサーバーや攻撃者に対する安全性が保証できないからで  ある .   このような設計は ,   与えたいアクセス権限以上の操作を可能としてしまうため ,   最小特権の原則 [Saltzer,  1974] に反している .  Capability  スケジューリング方針はハードウェア制約によって決定されるため ,   変更は困難である .   一方 ,   メモリ管理方針は ,  最小特権の原則に基づいた適切なセキュリティ機構を導入することにより ,   ユーザーレベルで決定することが可
能になる .  Object-Capability Model  その機構の実現には , Object-Capability Model を使用した Capability-Based Security を導入する .  Object-Capability Model とは ,   オブジェクトに対する操作権限を基にしたセキュリティモデルである .  ユーザーは特権的操作を行うために ,   自分の持つ Capability の指定子と ,   その Capability に対する操作を指定す  る必要がある .   ユーザーは自分の持たない Capability に対する操作手段は持ち得ず ,   割り当てられた権限以上  のことは行うことができない .   これは最小特権の原則を満たす .  A9N Microkernel  A9N Microkernel は ,   これまで記した問題に対する解法を単一のマイクロカーネルとして統合したものであり ,   私  が以前から開発しているものである .  A9N は ,   システム起動時にユーザーに許可する Capability を ,   Unix や Linux の Init に該当する実行可能コンテキ  スト Alpha へ渡す .   この Alpha が与えられた Capability をどう使用するかは , A9N をコアとする OS の実装者に一任  されている .   ユーザー空間上で動作する Alpha こそが OS の性格を決定するものであり ,   カーネルよりも上位レイ  ヤー部分の柔軟性を決定する .  シンプルなインターフェース  A9N はすべての特権操作を IPC メカニズムによって行う .   具体的には ,   IPC システムコールの第一引数として  Capability の識別子である Descriptor を指定することによって行われる .  この機構により , A9N のシステムコールは ipc() と yield() の２つのみという ,   究極的にシンプルなものとなる .  カーネルオブジェクト作成時の問題  カーネルは当然ながらメモリを使用する .   例えば ,   ある実行可能コンテキストを作成するには ,   カーネル内にそれ  専用のメタデータを作成する必要がある .  カーネルからメモリ管理方針をユーザーに移行した場合 ,   問題が発生する .   ユーザー側で割り当てたメモリを  カーネルへ渡した後 ,   メタデータの情報が漏洩する可能性があるということだ .  例えば ,   ある物理アドレスをカーネルへマップし ,   その情報を渡す場合 ,   割り当て先のアドレスを作成したオブジェ  クトのメタデータを示すデータ構造へキャストすると ,   カーネル内で使用する情報がそのまま手に入ってしまう .   こ  れはユーザーによるシステムの改竄が容易にし ,   信頼すべきセキュリティ機構を崩壊させてしまう .  メモリの抽象化  上記の問題を解決するためには ,   メモリ空間と操作権限を Capability とし ,   ユーザーが物理メモリアドレスを知る  ことが出来ないような設計にする必要がある .  そのために ,   汎用メモリ Capability : Generic と , Generic をカーネルオブジェクトへ変換する処理を導入する .  メモリを必要とするようなカーネルオブジェクトの作成と操作は ,   Generic を Convert して新たな Capability を作成  し ,   その Capability に対して操作を行うことで完了される .  物理メモリフレームもまた Capability : Frame であり ,   ユーザーのメモリ要求によってカーネルオブジェクトと同様  に作成される .  アドレス空間へのマッピングは Frame のみが許可されているため ,   所持していない物理メモリフレームは当然な  がらマッピングすることはできない .   また ,   カーネルオブジェクトは Generic から Convert することでしか作成できな  いため ,   情報漏洩を起こすようなこともない .  Generic を Generic へ Convert することにより ,   より小さな Generic を作成することも可能である .  システムのセキュアかつ柔軟な変更  メモリを Capability によって抽象化したことにより ,   従来のマイクロカーネルでは困難であった安全かつ柔軟なメ  モリ管理方針の決定が可能となる .   A9N はカーネル内ヒープを持たず ,   すべてをユーザーレベルで管理するた  め ,   特定のメモリ割り当てアルゴリズムに依存しない .  最初に作成したカーネルオブジェクトがそのままシステム終了時まで寿命を持ち ,   途中で動的に作成されるよう  なことがない組み込みシステムの場合は ,   一切の記録なしに Generic をただ Convert するだけの単純な割り当て  ポリシーで良い .  カーネルオブジェクトの生成と破棄を繰り返すようなデスクトップシステムの場合は ,   サーバーとしてユーザーラ  ンドで動作する Memory Management Server を作成し ,   メモリ割り当て要求はそのサーバーに対して行うことで
最適な動作を可能とする .   また ,   新しいメモリ割り当てアルゴリズムを試したい場合も新たなサーバーとして作成  するだけで完結し ,   処理に応じて動的にサーバーを切り替えることも容易である .  これはメモリ管理アルゴリズムに限らず ,   従来モノリシックカーネルが担ってきた機能の殆どを切り替えることが  できる .  Capability のセキュアな Addressing  Capability の指定子である Descriptor はメモリのアドレスを指し示すものではない .   これらの指定はある種間接  的なものとなっている .  ある実行可能コンテキストのグループが Process であり ,   Process はメモリ空間と Root   Capability   Node という  Capability を格納するための Node を持っている . Node もまた Capability であるため ,   ディレクトリのような構造を  持つことができる .  入れ子になった Capability を指し示すための機構が Descriptor による指定であり ,   ページテーブルと仮想アドレ  スの対応とよく似た構造を持つ . Descriptor は Node ごとに index へ分解され ,   終端まで探索される .   この方式によ  る探索速度は O(log n) であり ,   非常に高速である .  Capability そのものを表すメタデータはカーネルの内部に隠蔽されているため ,   不正なアクセスは不可能である .  また ,   各 Process の持つ Capability Node の構造は異なるため ,   別プロセスにおいて有効な Descriptor のコピー  は不可能である .  Capability に対する CRUD  Capability は ,   それを保持する親 Node から  ●   remove  ●   revoke  ●   move  ●   copy  の操作が可能である .   この機構により ,   カーネルが最初に起動するユーザーランドサーバーである Alpha Server  は ,   子に自分の持つ Capability を委譲し ,   それぞれが最小の特権を持つサーバーへ分散することが可能である .  実体を持たない Capability  Node 内の Capability   Slot に Capability を表す情報が格納される .   Capability の実体を指す個別のポインタと ,  Slot 固有の Slot Data である .  Slot   Data の存在により , Generic や Frame などの個別にインスタンスを持たせたくない Capability に対する処理  を単一の Manager Object へ委譲するだけで完結できる .  HAL  カーネルはハードウェアとの接続に HAL を使用する .   ハードウェア依存部分は HAL に集約されているため ,   異な  るアーキテクチャやボードに移植することが容易となる .   デバイスドライバーは DMA を行うためこの限りではない  が ,   ユーザーから見えるカーネルの API は等しいため ,   殆どのサーバーはアーキテクチャを変更し再ビルドする  だけで動作する .  これにより ,   デスクトップ環境向けやインターネット・サーバー環境向けのメモリ管理システムを組み込み向け環  境へ移植することや ,   その逆を変更なしに動作させることが可能となり ,   各システム間の統合を可能とする .  本提案ではカーネルのターゲットアーキテクチャを x86_64 に絞るが ,   基本的にサーバーはアーキテクチャ非依  存である .  KOITO  KOITO は A9N マイクロカーネルをコアとする OS である .  実装するユーザーレベルメモリ管理システムは KOITO 上に起動するサーバーによって動作する .   また ,   システム  のテストや各種アプリケーションの実装も KOITO 上で行う .  本提案に対する KOITO の比重はそこまで大きくなく ,   あくまでもカーネルと各サーバーを接続するために実装さ  れる .
ライブラリ  liba9n  liba9n は , C によって実装する , A9N カーネルを呼び出すための最もプリミティブな API ライブラリである . IPC や ,  それをラップする各 Capability への操作はこのライブラリを用いて行う .  Capability によるカーネルコールと ,   それに必要な共通の定数やアーキテクチャ非依存のデータ構造を提供す  る . liba9n における実際の IPC 呼び出し部分は ,   アセンブリで記述されるためハードウェアに依存する .  koito-libc  koit-libc は , C によって実装する , KOITO 上で動作させるソフトウェアが個別に使用する libc 互換ライブラリであり ,  これによる Unix ソフトウェアの移植を目指す .  libc には標準ユーティリティライブラリとしての側面と ,   システムコールラッパーとしての側面があるが ,   koito-libc  内のシステムコールに該当する関数呼び出しは内部で機能を持つサーバーにメッセージを送信し ,   処理を委譲  することによって行う .  ULMM Server  ULMM   Server は ,   本プロジェクトのメインである Capability を用いたユーザーレベルメモリ管理を実装するサー  バーである . Capability を管理・分割し ,   要求されたメモリ関連呼び出しに対して適切に割り当てを行う .  このサーバーで実装するのは ,  ●   カーネルオブジェクトを Allocate するための SLAB Allocator  ●   ページフレーム単位でユーザーにメモリを割り当てるための Buddy Allocator  の 2 つである .  SLAB Allocator  ULMM Server の SLAB はカーネルオブジェクトを効率的に割り当てるための Allocator である .  Capability のタイプと個数をリクエストすることによってキャッシュが作成され , Generic 内の領域を予約する .  各 Capability のサイズはカーネルにより 2 の累乗バイトであると規定されているため ,   Generic に対する Convert  の比較的薄いラッパーとなる .  Buddy Allocator  ULMM Server の Buddy Allocator は , Buddy System を用いて Generic を管理し ,   要求されたページフレームを  割り当てる Allocator である .  Generic は派生したオブジェクトをすべて破棄しなければ再利用ができない .   また , Generic のサイズを後から知  ることもできないため ,   Generic からカーネルオブジェクトを Convert するタイミングで管理情報をユーザーレベル  で保持しなければならない .  そのため , SLAB とは異なり ,   このサーバーは管理情報分の Frame を自分自身に割り当て ,   そこに管理情報を書  き込み , Allocation 時のヒントとしなければならない .   そのため , SLAB よりも実装コストは高くなる .  2.   どんな出し方を考えているか  提案の実装である A9N Microkernel + OS + Userlevel Memory Allocator は , MIT ライセンスのもと GitHub 上に  公開するものとする .   また ,   それらを適切に使用するためのマニュアルも公開する .  マニュアル作成用の組版エンジンとして Typst を用い , Typst コードも公開する .  本システムのユーザー拡大のためにはそれらは必須事項である .   セキュアを謳うクローズドなシステムには透明  性が欠けていることや ,   オープンなシステムであっても使用方法が理解できなければ意味が無いためである .  3.   斬新さの主張、期待される効果など  先行研究  Capability-Based   Microkernel であり ,   カーネル内ヒープを持たない先行事例として seL4[seL4] が挙げられる .
seL4 もまた libseL4[libsel4](libsel4allocman, libsel4vka) によるユーザーレベルメモリ割り当てシステムを持って  いるが ,   本提案のような Allocator よりも低レベルを示す , 生の Capability 操作に近いものである .  また , seL4 の API は本質的にハードウェアに依存しており ,   アーキテクチャ固有の Page Table を自らマップしなけ  ればならないなど ,   API レベルでの互換性が考慮されていない .   このことから seL4 は A9N よりも柔軟度が低いと  いえる .  本提案はメモリ管理機構そのものの柔軟性を謳っているため ,   新規性が認められると考える .  また ,   前年度未踏 IT プロジェクトである Caprese[Caprese] は ,   Capability を主軸とするマイクロカーネルの開発  がメインであり ,   一見領域が同一な提案に思えるが ,   本提案におけるカーネル部分はほぼ完成していて ,   メインと  なる部分はあくまでもユーザーレベルメモリ管理システムであるため ,   全く別の提案であるといえる .  仮想化システムにおける 2 レベルのセキュリティと最適化  近年のセキュアな仮想化システムには Container, WASM, Hypervisor などが挙げられるが ,   本提案はそのいず  れとも親和性が高い .  カーネルレベルのセキュリティとそれらの持つセキュリティは ,   冗長なようでそうではない .   各システムが存在する  レイヤーごとにセキュリティ機構が必要であり ,   むしろ必要なものである .  また ,   システムごとに最適なメモリ割り当て方針を決定できることにより ,   従来のものと比較して高速なものを提  供することが可能となる .   これにより ,   本提案のユーザーはよりセキュアで高速な実行環境を手に入れることがで  きる .  4.   具体的な進め方と予算  開発を行う場所  自宅  使用するハードウェア  メイン開発用計算機   : Apple MacBook Pro 2023 (AArch64 : Apple M2 Pro, 16GB RAM, 512GB SSD)  サブ開発用計算機   :   自作デスクトップ PC (x86_64 : AMD Ryzen7 2700, 32GB RAM, 512GB SSD)  使用するソフトウェア / ツール  OS  基本的に Docker Container 上で作業を行う .  Host : macOS Ventura 13.5  Host (Sub) : Windows 11 23H2  Guest : Debian 11 Bullseye on Docker : Apple Silicon の場合 , Rosetta2 による仮想環境を使用する  Language  C++20 :   メインで使用  C11 :   ブートローダー , ASM とのグルーコード , liba9n, koito-libc の標準実装に使用  ASM (x86_64) : A9N Microkernel, liba9n のハードウェア依存部分に使用  Build  Clang  Clang++  lld  NASM  EDK2 :   ブートローダーのビルドに使用する  Test  Google Test :   テスト駆動開発を行う
Debug  LLVM Binutils  QEMU  Manual  Typst  開発線表  6 月   7 月   8 月   9 月   10 月   11 月   12 月   1 月   2 月  A9N   Capability の実装   レガシー  コードの置  き換え  すり合わ  せ  ドキュメント整備   発表準備  KOITO   koito-libc の実装   Unix ソフトウェアの移植  ULMM   SLAB の実装   Buddy System の実装   リファクタリング  開発に関わる時間帯と時間数  現在学生ではなく ,   また就職もしていないため ,   フルタイムで一日当たり 8 時間 ,   週平均 48 時間程度作業を行う予  定である .  予算内訳  活動時間   (h)   予算   ( 円 )  1440   2,880,000  5.   提案者の腕前を証明できるもの  本提案で使用する Capability-Based Microkernel である A9N は ,   一般社団法人未踏による未踏ジュニアに採択  され作成したものである [A9N].   このカーネルは当初 , HAL を備えたマイクロカーネルであったが ,   採択期間の終  了後から Capability-Based なものへと書き換えを行っている .   この A9N が高い評価を得たため ,   スーパークリ  エータの称号を獲得した [ スーパークリエータ ].   また ,   未踏会議 2024 への展示を行った .  このカーネルを作成するにあたり ,   オペレーティングシステムの理論 , C, C++, ASM(x86_64) や Docker によるエ  コシステムの深い理解を得た .  得られた知見は Scrapbox[Scrapbox] へ出力し ,   x86_64 アーキテクチャや seL4 に関する記事を作成した ,   また ,  採択期間で得られたカーネルを書くための手法を Zenn[ カーネルことはじめ ] の記事として作成し ,   Ideas   Trend  の 2 位となった .  Github[Github] では Python + DDD による Restful な OAuth2 ROPC Server の実装や , Object-Oriented なアプ  ローチを用いた NES エミュレータの実装を行っている . A9N は , Capability System が完成次第 Public なものとな  る .  6.   プロジェクト遂行にあたっての特記事項  大学入学にあたる年齢だが ,   受験においては春 AO を考えているため現在はどこにも所属していない .
7. IT 以外の勉強、特技、生活、趣味など  IT 以外の趣味は多岐に渡る .   というのも ,   面白そうなことはまずやってみるというスタンスで生きてきた結果 ,   消え  ることなく上に積み上がっていったからである .  音楽に関しては ,   制作面でいうと電子音楽の作曲 [SoundCloud] や和声法 ,   対位法の学習を行っている .   また ,   演  奏面に関してはピアノ ,   ギター ,   ベース ,   シンセサイザーなどを楽しんでいる .  グラフィックスに関しては ,   美術解剖学を学んだり ,   パースを学んだり ,   デザインを行っている . 3DCG でいうとモデ  リングや VFX を行っており ,   実写合成 [ 実写合成動画 ] が評価され CPU メーカーの AMD からノベルティ贈呈を得た  ことがある .  考古学に関しては ,   主に古代エジプトを嗜んでいる .   ヒエログリフの解読が多少できる .  8.   将来の IT について思うこと・期すること  レガシーなコードは将来のユーザーを苦しめる .   特に ,   カーネルや OS のような形を変えにくいものに関しては ,   永  久に更新できない負の遺産が何重にも積み重なることになる .  変えにくいからこそ ,   慎重に設計しなければならないし ,   レガシーな部分を置換できるような設計でなければなら  ないのに ,   殆どのシステム・ソフトウェアについてその観点が欠けているように思える .  現代 ,   それらのシステムは肥大し ,   誰も全容を把握できなくなった .   モノリスな構造は API の肥大を招き ,   もはや置  き換えることは不可能になり ,   Attack   Surface の拡大によるセキュリティ上のリスクはそれに比例して大きくなっ  ていった .  今こそマイクロカーネルが復興のときである .   第 1 世代マイクロカーネルの Mach はその遅さから普及しなかった .  普及のために脱マイクロカーネルへ舵を切り , BSD のコードと統合され , XNU へと名前を変えた .  第 2 世代マイクロカーネルは IPC の高速化によって実用に近いものとなり ,   seL4 の前身である L4-embedded は  世界中の iOS 端末に搭載されるようになった .  そして第 3 世代マイクロカーネルが誕生した . seL4 や Fiasco.OC, Nova の台頭により ,   セキュアかつ高速なマイク  ロカーネルが完全に実用的になったのである .   コンピューターアーキテクチャとソフトウェアアーキテクチャの進  化が融合し ,   仮想化技術に迎合する新たなシステムの時代が幕を開けたのである .  これらは長い研究と苦労の産物である .   先人たちがそうであったように ,   第 4 世代のマイクロカーネルに向けた歩  みを止めてはならないと強く感じる .   そして ,   それを実現し得る若い世代に期待したい .  9.   参考文献  [Tanenbaum, 2007] Tanenbaum, A S.: “ モダン オペレーティング システム 原著第二版 ”,  ( 水野忠則・太田剛・最所 圭三・福田晃・吉沢康文 訳 ),   ピアソン・エデュケーション・ジャパン , 2007.  [Liedtke, 1995] Liedtke, J.: “Improving IPC by Kernel Design” Proc. 14th Symp. on Operating Systems  Principles, ACM, pp. 237-150, 1995.  [Levin   et   al,   1975]   Levin,   R.,   Cochen,   E.S.,   Corwin,   W.M.,   Pollack,   F.J.,   and   Wulf.,   W.A.:  “Policy/Mechanism Separation in Hydra”, Proc. 5th Symp, on Operating Systems Principles, ACM, pp.  132-140, 1975.  [Saltzer, 1974] Saltzer, J.H., and Schroeder, M.D.: “Protection and Control of Information Sharing in  MULTICS”, Commun. of the ACM, vol.17, pp.388-402, 1974  [seL4] https://sel4.systems/  [libsel4] https://github.com/seL4/seL4_libs  [Caprese] https://www.ipa.go.jp/jinzai/mitou/it/2023/gaiyou_tn-4.html  [A9N] https://jr.mitou.org/projects/2023/a9n  [ スーパークリエータ ] https://jr.mitou.org/projects/  [Scrapbox] https://scrapbox.io/horizon2038/  [ カーネルことはじめ ] https://zenn.dev/horizon2k38/articles/6e0ea0570c98fb  [Github] https://github.com/horizon2038  [SoundCloud] https://soundcloud.com/user-571923716  [ 実写合成 ] https://twitter.com/horizon2k38/status/1270246466217336832
